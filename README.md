# Operational/axiomatic sequential refinement proof
# THIS IS AN OLD, FORKED VERSION OF ARCHSEM ONLY USED FOR THIS VERY SPECIFIC PROOF

**For the actual, up-to-date ArchSem refer to the main supplemented archive.**
This development should only be used to inspect the proof that the operational
sequential model refines the SC axiomatic model.

The proof can be found in [ArchSemArm/ArmSeqAxOpEq.v](ArchSemArm/ArmSeqAxOpEq.v) and
is annotated with explanatory comments in situ.

Expressively, the main result of this refinement proof is the following.

We assume
- any memory access issued by the instruction semantics
  has size â‰  0 and < 2 ^ 52
- a sequential state that was computed by the operational sequential model without error
- no mixed-size memory accesses in the operational model trace

and prove that the computed candidate execution has the same trace
is **consistent** and **well-formed** w.r.t. the SC aciomatic model!

The result follows directly from the sequential model maintaining the big invariant record defined above.

The proof itself is a standard induction over a trace generated by the sequential operational model.
For that, we show that the empty/initial sequential state satisfies a long list of properties in one predicate.
Then we show that this predicate is an invariant preserved by the sequential model in each step.

Putting these together we obtain the refinement result

## Building

See [INSTALL.md](INSTALL.md) for dependencies, installation, and build
instructions.

## Rocq automation

There are some powerful custom tactics in `Common`, as well as useful but
generic library. See the [README](Common/README.md) there for more details. In
particular `cdestruct` is in [Common/CDestruct.v](Common/CDestruct.v).



## Documentation

To build the documentation call `dune build @doc` and then the documentation
will be generated in:

- `_build/default/Common/ASCommon.html/toc.html`
- `_build/default/ArchSem/ArchSem.html/toc.html`
- `_build/default/ArchSemArm/ArchSemArm.html/toc.html`
